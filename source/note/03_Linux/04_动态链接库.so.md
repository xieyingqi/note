# 动态链接库.so

## 命名规则

Linux中的.so文件 是动态链接的产物，共享库理解为提供各种功能函数的集合，对外提供标准的接口

**Linux中命名系统中共享库的规则**

![动态库命名](pic/20190813092818996.png)

**主版本号：不同的版本号之间不兼容**

**次版本号：增量升级 向后兼容**

**发行版本号：对应次版本的错误修正和性能提升，不影响兼容性**

为方便管理依赖关系，创建或部署共享库时，必须遵循统一约定的规则才行，其中包括动态库的命名规则及其部署方式。共享库命名约定：

1. 每个动态库有一个包含了真正的库代码的文件名，通常被称为库的 realname ，命名格式通常为libxxx.so.x.y.z，其中so后缀中的x为主版本号，y为副版本号，z为发行版本号。例如，我的linux系统机器上zlib共享库的realname为 libz.so.1.2.8，这个文件是含有可执行的二进制代码的。
2. 每个动态库都有一个以"lib"为前缀且以".so.x"为结尾的被称为 soname的特定名称，其中x为主版本号，soname命名格式通常为libxxx.so.x。例如，我的linux系统机器上zlib共享库的soname为libz.so.1。这个soname包含了动态库的主版本号，这个doname一般会包含在库代码的头文件中，这个可以使用 readelf -d 读取出来，使用这个动态库的程序的二进制ELF的头文件中包含有这个动态库的soname。程序运行时会按照这个名称去找真正的库文件。
3. 此外，编译链依赖了共享库的应用模块时，**链接器只认不带任何版本号的共享库名**， 可以将库名称作" linker name。例如，我的linux系统机器上zlib共享库的linkername为libz.so。也即，链接使用了动态库的程序时查找的动态库名称。例如：gcc -o test test.o -lz , 链接时就会找libz.so。若没有这个文件，链接器就报错

## 编译和使用.so库

### 编译

```shell
gcc -fpic -shared modbus.c -o libmodbus.so
```

### 使用

```shell
gcc commu.c -o commu -L ../libmodbus -l modbus
```

* `-L` 为.so所在目录
* `-l`为库名（libmodbus.so）(小写字母L)
* `-I`.h头文件所在的目录（大写字母I）
* 注：libmodbus.so应放在`/usr/lib`中，因编译时自动去该目录下找

### 注意

-L的库文件要以.so结尾，而不能是.so.x.x结尾，否则提示找不到。通过软链接的方式将.so.x.x链接到.so

