# 类和对象

## 类
类是一种***数据类型***的声明，不占用内存空间，包括成员变量（属性）和成员函数（方法）；
```cpp
/* 定义Student类 */
class Student
{
public:
	char *name;
	void func(){};
};
```
## 对象
由类创建的实体变量（实例化），占用内存空间
```cpp
Student stu; //创建对象
```

## 对象指针

```cpp
/* 栈区创建 */
Student stu;
Stuedent *pstu = &stu;  //指针需要指向一个具体的变量

/* 堆区创建 */
Student *pstu = new Student;  //new创建只得到一个指针，必须定义一个指针变量来接收
```

## 类的成员函数
* 成员函数可以在类体中声明，在类体外实现；
* 实现时，需要在函数名前加上`::`以表明该函数属于哪个类（先声明，后定义！）
* 在类体内实现时，默认为内联函数；
* 常用方式为在类体外实现

## 类成员访问权限
* 在类的内部，无访问限制；
* 在类的外部，只能通过对象访问public的成员，但通过对象也不能访问protected和private属性的成员。可通过函数访问

## 封装
尽量隐藏类的内部实现，只向用户提供有用的成员函数

## 构造函数
**作用：** 创建对象时，对成员变量进行赋值
**注意：**
* 可重载
* 不允许有返回值
* 如果未自定义构造函数，编译器会自动生成；如果定义了构造函数，则创建对象时必须调用；

**构造函数的两种形式：**
```cpp
/* 一般方式 */
Student::Student(char *name, int age, float score){
    m_name = name;
    m_age = age;
    m_score = score;
}
/* 初始化列表方式 */
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
    //
}
```
使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。

初始化列表可以用于全部成员变量，也可以只用于部分成员变量。下面的示例只对 m_name 使用初始化列表，其他成员变量还是一一赋值：
```cpp
Student::Student(char *name, int age, float score): m_name(name){
    m_age = age;
    m_score = score;
}
```
## 析构函数
* 一般多用于释放内存；
* 调用时机：
    * 通过new创建的对象：在delete后才会执行析；
    * 全局对象：程序执行结束时执行；
    * 局部对象：函数执行结束后执行

# this指针
* 关键字，用于指向当前对象，可访问当前对象的所有成员；
* 只能在类的内部使用（this指针不可手动赋值，只有在创建对象后才会被自动赋值）

# 静态成员变量
* 与普通static变量一样，在全局区分配内存，必须初始化，初始化时分配内存，即使对象销毁也不释放他的内存；
* 所有的对象可共享，可通过对象访问，也可通过类名访问（类名::变量），遵循权限限制

# 静态成员函数
* 只能访问静态成员变量
* 声明时加static关键字，定义时不加
* 普通成员函数在创建对象时有this指针，指向当前对象，占用当前对象内存；而静态成员函数无this指针，无法指定变量属于哪个对象，故无法访问普通成员变量

# const 成员变量/函数/对象
**const成员变量：**
* 声明时加const，**只可以**通过构造函数初始化列表的方式进行初始化

**const成员函数：**
* 可以使用类中的所有成员变量，但是不能修改他们的值；
* 声明和定义时要在函数头部的结尾加上const关键字：
```cpp
/* 声明常成员函数 */
char *getname() const;

/* 定义常成员函数 */
char * Student::getname() const{
	return m_name;
}
```
**const对象：**
* 只能调用类的const成员变量或const成员函数

# 友元
* 使用其他类或全局函数访问当前类的private成员；
```cpp

```

//TODO